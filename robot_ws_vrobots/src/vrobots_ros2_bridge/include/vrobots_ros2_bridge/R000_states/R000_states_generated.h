// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_R000STATES_H_
#define FLATBUFFERS_GENERATED_R000STATES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct Vec3Msg;
struct Vec3MsgBuilder;
struct Vec3MsgT;

struct Vec4Msg;
struct Vec4MsgBuilder;
struct Vec4MsgT;

struct Collision;
struct CollisionBuilder;
struct CollisionT;

struct StatesMsg;
struct StatesMsgBuilder;
struct StatesMsgT;

struct Vec3MsgT : public ::flatbuffers::NativeTable {
  typedef Vec3Msg TableType;
  float x = 0.0f;
  float y = 0.0f;
  float z = 0.0f;
};

struct Vec3Msg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vec3MsgT NativeTableType;
  typedef Vec3MsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           verifier.EndTable();
  }
  Vec3MsgT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Vec3MsgT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Vec3Msg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Vec3MsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Vec3MsgBuilder {
  typedef Vec3Msg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vec3Msg::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vec3Msg::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Vec3Msg::VT_Z, z, 0.0f);
  }
  explicit Vec3MsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vec3Msg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vec3Msg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vec3Msg> CreateVec3Msg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  Vec3MsgBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

::flatbuffers::Offset<Vec3Msg> CreateVec3Msg(::flatbuffers::FlatBufferBuilder &_fbb, const Vec3MsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Vec4MsgT : public ::flatbuffers::NativeTable {
  typedef Vec4Msg TableType;
  float x = 0.0f;
  float y = 0.0f;
  float z = 0.0f;
  float w = 0.0f;
};

struct Vec4Msg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vec4MsgT NativeTableType;
  typedef Vec4MsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_W = 10
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  float w() const {
    return GetField<float>(VT_W, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           VerifyField<float>(verifier, VT_W, 4) &&
           verifier.EndTable();
  }
  Vec4MsgT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Vec4MsgT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Vec4Msg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Vec4MsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Vec4MsgBuilder {
  typedef Vec4Msg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vec4Msg::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vec4Msg::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Vec4Msg::VT_Z, z, 0.0f);
  }
  void add_w(float w) {
    fbb_.AddElement<float>(Vec4Msg::VT_W, w, 0.0f);
  }
  explicit Vec4MsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vec4Msg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vec4Msg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vec4Msg> CreateVec4Msg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    float w = 0.0f) {
  Vec4MsgBuilder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

::flatbuffers::Offset<Vec4Msg> CreateVec4Msg(::flatbuffers::FlatBufferBuilder &_fbb, const Vec4MsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CollisionT : public ::flatbuffers::NativeTable {
  typedef Collision TableType;
  double timestamp = 0.0;
  uint8_t collision_type = 0;
  std::string object_name{};
  std::unique_ptr<Vec3MsgT> pos{};
  std::unique_ptr<Vec3MsgT> vel{};
  std::unique_ptr<Vec3MsgT> eul{};
  std::unique_ptr<Vec3MsgT> angvel{};
  CollisionT() = default;
  CollisionT(const CollisionT &o);
  CollisionT(CollisionT&&) FLATBUFFERS_NOEXCEPT = default;
  CollisionT &operator=(CollisionT o) FLATBUFFERS_NOEXCEPT;
};

struct Collision FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CollisionT NativeTableType;
  typedef CollisionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_COLLISION_TYPE = 6,
    VT_OBJECT_NAME = 8,
    VT_POS = 10,
    VT_VEL = 12,
    VT_EUL = 14,
    VT_ANGVEL = 16
  };
  double timestamp() const {
    return GetField<double>(VT_TIMESTAMP, 0.0);
  }
  uint8_t collision_type() const {
    return GetField<uint8_t>(VT_COLLISION_TYPE, 0);
  }
  const ::flatbuffers::String *object_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_NAME);
  }
  const Vec3Msg *pos() const {
    return GetPointer<const Vec3Msg *>(VT_POS);
  }
  const Vec3Msg *vel() const {
    return GetPointer<const Vec3Msg *>(VT_VEL);
  }
  const Vec3Msg *eul() const {
    return GetPointer<const Vec3Msg *>(VT_EUL);
  }
  const Vec3Msg *angvel() const {
    return GetPointer<const Vec3Msg *>(VT_ANGVEL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint8_t>(verifier, VT_COLLISION_TYPE, 1) &&
           VerifyOffset(verifier, VT_OBJECT_NAME) &&
           verifier.VerifyString(object_name()) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyOffset(verifier, VT_VEL) &&
           verifier.VerifyTable(vel()) &&
           VerifyOffset(verifier, VT_EUL) &&
           verifier.VerifyTable(eul()) &&
           VerifyOffset(verifier, VT_ANGVEL) &&
           verifier.VerifyTable(angvel()) &&
           verifier.EndTable();
  }
  CollisionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CollisionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Collision> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CollisionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CollisionBuilder {
  typedef Collision Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(double timestamp) {
    fbb_.AddElement<double>(Collision::VT_TIMESTAMP, timestamp, 0.0);
  }
  void add_collision_type(uint8_t collision_type) {
    fbb_.AddElement<uint8_t>(Collision::VT_COLLISION_TYPE, collision_type, 0);
  }
  void add_object_name(::flatbuffers::Offset<::flatbuffers::String> object_name) {
    fbb_.AddOffset(Collision::VT_OBJECT_NAME, object_name);
  }
  void add_pos(::flatbuffers::Offset<Vec3Msg> pos) {
    fbb_.AddOffset(Collision::VT_POS, pos);
  }
  void add_vel(::flatbuffers::Offset<Vec3Msg> vel) {
    fbb_.AddOffset(Collision::VT_VEL, vel);
  }
  void add_eul(::flatbuffers::Offset<Vec3Msg> eul) {
    fbb_.AddOffset(Collision::VT_EUL, eul);
  }
  void add_angvel(::flatbuffers::Offset<Vec3Msg> angvel) {
    fbb_.AddOffset(Collision::VT_ANGVEL, angvel);
  }
  explicit CollisionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Collision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Collision>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Collision> CreateCollision(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double timestamp = 0.0,
    uint8_t collision_type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> object_name = 0,
    ::flatbuffers::Offset<Vec3Msg> pos = 0,
    ::flatbuffers::Offset<Vec3Msg> vel = 0,
    ::flatbuffers::Offset<Vec3Msg> eul = 0,
    ::flatbuffers::Offset<Vec3Msg> angvel = 0) {
  CollisionBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_angvel(angvel);
  builder_.add_eul(eul);
  builder_.add_vel(vel);
  builder_.add_pos(pos);
  builder_.add_object_name(object_name);
  builder_.add_collision_type(collision_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Collision> CreateCollisionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double timestamp = 0.0,
    uint8_t collision_type = 0,
    const char *object_name = nullptr,
    ::flatbuffers::Offset<Vec3Msg> pos = 0,
    ::flatbuffers::Offset<Vec3Msg> vel = 0,
    ::flatbuffers::Offset<Vec3Msg> eul = 0,
    ::flatbuffers::Offset<Vec3Msg> angvel = 0) {
  auto object_name__ = object_name ? _fbb.CreateString(object_name) : 0;
  return CreateCollision(
      _fbb,
      timestamp,
      collision_type,
      object_name__,
      pos,
      vel,
      eul,
      angvel);
}

::flatbuffers::Offset<Collision> CreateCollision(::flatbuffers::FlatBufferBuilder &_fbb, const CollisionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StatesMsgT : public ::flatbuffers::NativeTable {
  typedef StatesMsg TableType;
  std::string name{};
  uint32_t sys_id = 0;
  double timestamp = 0.0;
  std::unique_ptr<Vec3MsgT> lin_acc{};
  std::unique_ptr<Vec3MsgT> lin_vel{};
  std::unique_ptr<Vec3MsgT> lin_pos{};
  float altitude = 0.0f;
  std::unique_ptr<Vec3MsgT> ang_acc{};
  std::unique_ptr<Vec3MsgT> ang_vel{};
  std::unique_ptr<Vec3MsgT> euler{};
  std::unique_ptr<Vec3MsgT> euler_dot{};
  std::unique_ptr<Vec4MsgT> quaternion{};
  std::vector<uint32_t> pwm{};
  std::vector<float> actuators{};
  std::unique_ptr<Vec3MsgT> force{};
  std::unique_ptr<Vec3MsgT> torque{};
  std::unique_ptr<Vec3MsgT> accelerometer{};
  std::unique_ptr<Vec3MsgT> gyroscope{};
  std::unique_ptr<Vec3MsgT> magnetometer{};
  float barometer = 0.0f;
  float temperature = 0.0f;
  std::unique_ptr<Vec3MsgT> gps_pos{};
  std::unique_ptr<Vec3MsgT> gps_vel{};
  float mass = 0.0f;
  std::unique_ptr<Vec3MsgT> cg{};
  std::vector<float> moment_arms{};
  std::unique_ptr<Vec3MsgT> moi_3x1{};
  std::vector<float> moi_3x3{};
  std::vector<float> extra_props{};
  std::vector<std::unique_ptr<CollisionT>> collisions{};
  std::vector<uint8_t> image_data_0{};
  std::vector<uint8_t> image_data_1{};
  StatesMsgT() = default;
  StatesMsgT(const StatesMsgT &o);
  StatesMsgT(StatesMsgT&&) FLATBUFFERS_NOEXCEPT = default;
  StatesMsgT &operator=(StatesMsgT o) FLATBUFFERS_NOEXCEPT;
};

struct StatesMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatesMsgT NativeTableType;
  typedef StatesMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SYS_ID = 6,
    VT_TIMESTAMP = 8,
    VT_LIN_ACC = 10,
    VT_LIN_VEL = 12,
    VT_LIN_POS = 14,
    VT_ALTITUDE = 16,
    VT_ANG_ACC = 18,
    VT_ANG_VEL = 20,
    VT_EULER = 22,
    VT_EULER_DOT = 24,
    VT_QUATERNION = 26,
    VT_PWM = 28,
    VT_ACTUATORS = 30,
    VT_FORCE = 32,
    VT_TORQUE = 34,
    VT_ACCELEROMETER = 36,
    VT_GYROSCOPE = 38,
    VT_MAGNETOMETER = 40,
    VT_BAROMETER = 42,
    VT_TEMPERATURE = 44,
    VT_GPS_POS = 46,
    VT_GPS_VEL = 48,
    VT_MASS = 50,
    VT_CG = 52,
    VT_MOMENT_ARMS = 54,
    VT_MOI_3X1 = 56,
    VT_MOI_3X3 = 58,
    VT_EXTRA_PROPS = 60,
    VT_COLLISIONS = 62,
    VT_IMAGE_DATA_0 = 64,
    VT_IMAGE_DATA_1 = 66
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t sys_id() const {
    return GetField<uint32_t>(VT_SYS_ID, 0);
  }
  double timestamp() const {
    return GetField<double>(VT_TIMESTAMP, 0.0);
  }
  const Vec3Msg *lin_acc() const {
    return GetPointer<const Vec3Msg *>(VT_LIN_ACC);
  }
  const Vec3Msg *lin_vel() const {
    return GetPointer<const Vec3Msg *>(VT_LIN_VEL);
  }
  const Vec3Msg *lin_pos() const {
    return GetPointer<const Vec3Msg *>(VT_LIN_POS);
  }
  float altitude() const {
    return GetField<float>(VT_ALTITUDE, 0.0f);
  }
  const Vec3Msg *ang_acc() const {
    return GetPointer<const Vec3Msg *>(VT_ANG_ACC);
  }
  const Vec3Msg *ang_vel() const {
    return GetPointer<const Vec3Msg *>(VT_ANG_VEL);
  }
  const Vec3Msg *euler() const {
    return GetPointer<const Vec3Msg *>(VT_EULER);
  }
  const Vec3Msg *euler_dot() const {
    return GetPointer<const Vec3Msg *>(VT_EULER_DOT);
  }
  const Vec4Msg *quaternion() const {
    return GetPointer<const Vec4Msg *>(VT_QUATERNION);
  }
  const ::flatbuffers::Vector<uint32_t> *pwm() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_PWM);
  }
  const ::flatbuffers::Vector<float> *actuators() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ACTUATORS);
  }
  const Vec3Msg *force() const {
    return GetPointer<const Vec3Msg *>(VT_FORCE);
  }
  const Vec3Msg *torque() const {
    return GetPointer<const Vec3Msg *>(VT_TORQUE);
  }
  const Vec3Msg *accelerometer() const {
    return GetPointer<const Vec3Msg *>(VT_ACCELEROMETER);
  }
  const Vec3Msg *gyroscope() const {
    return GetPointer<const Vec3Msg *>(VT_GYROSCOPE);
  }
  const Vec3Msg *magnetometer() const {
    return GetPointer<const Vec3Msg *>(VT_MAGNETOMETER);
  }
  float barometer() const {
    return GetField<float>(VT_BAROMETER, 0.0f);
  }
  float temperature() const {
    return GetField<float>(VT_TEMPERATURE, 0.0f);
  }
  const Vec3Msg *gps_pos() const {
    return GetPointer<const Vec3Msg *>(VT_GPS_POS);
  }
  const Vec3Msg *gps_vel() const {
    return GetPointer<const Vec3Msg *>(VT_GPS_VEL);
  }
  float mass() const {
    return GetField<float>(VT_MASS, 0.0f);
  }
  const Vec3Msg *cg() const {
    return GetPointer<const Vec3Msg *>(VT_CG);
  }
  const ::flatbuffers::Vector<float> *moment_arms() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MOMENT_ARMS);
  }
  const Vec3Msg *moi_3x1() const {
    return GetPointer<const Vec3Msg *>(VT_MOI_3X1);
  }
  const ::flatbuffers::Vector<float> *moi_3x3() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MOI_3X3);
  }
  const ::flatbuffers::Vector<float> *extra_props() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_EXTRA_PROPS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Collision>> *collisions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Collision>> *>(VT_COLLISIONS);
  }
  const ::flatbuffers::Vector<uint8_t> *image_data_0() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_IMAGE_DATA_0);
  }
  const ::flatbuffers::Vector<uint8_t> *image_data_1() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_IMAGE_DATA_1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SYS_ID, 4) &&
           VerifyField<double>(verifier, VT_TIMESTAMP, 8) &&
           VerifyOffset(verifier, VT_LIN_ACC) &&
           verifier.VerifyTable(lin_acc()) &&
           VerifyOffset(verifier, VT_LIN_VEL) &&
           verifier.VerifyTable(lin_vel()) &&
           VerifyOffset(verifier, VT_LIN_POS) &&
           verifier.VerifyTable(lin_pos()) &&
           VerifyField<float>(verifier, VT_ALTITUDE, 4) &&
           VerifyOffset(verifier, VT_ANG_ACC) &&
           verifier.VerifyTable(ang_acc()) &&
           VerifyOffset(verifier, VT_ANG_VEL) &&
           verifier.VerifyTable(ang_vel()) &&
           VerifyOffset(verifier, VT_EULER) &&
           verifier.VerifyTable(euler()) &&
           VerifyOffset(verifier, VT_EULER_DOT) &&
           verifier.VerifyTable(euler_dot()) &&
           VerifyOffset(verifier, VT_QUATERNION) &&
           verifier.VerifyTable(quaternion()) &&
           VerifyOffset(verifier, VT_PWM) &&
           verifier.VerifyVector(pwm()) &&
           VerifyOffset(verifier, VT_ACTUATORS) &&
           verifier.VerifyVector(actuators()) &&
           VerifyOffset(verifier, VT_FORCE) &&
           verifier.VerifyTable(force()) &&
           VerifyOffset(verifier, VT_TORQUE) &&
           verifier.VerifyTable(torque()) &&
           VerifyOffset(verifier, VT_ACCELEROMETER) &&
           verifier.VerifyTable(accelerometer()) &&
           VerifyOffset(verifier, VT_GYROSCOPE) &&
           verifier.VerifyTable(gyroscope()) &&
           VerifyOffset(verifier, VT_MAGNETOMETER) &&
           verifier.VerifyTable(magnetometer()) &&
           VerifyField<float>(verifier, VT_BAROMETER, 4) &&
           VerifyField<float>(verifier, VT_TEMPERATURE, 4) &&
           VerifyOffset(verifier, VT_GPS_POS) &&
           verifier.VerifyTable(gps_pos()) &&
           VerifyOffset(verifier, VT_GPS_VEL) &&
           verifier.VerifyTable(gps_vel()) &&
           VerifyField<float>(verifier, VT_MASS, 4) &&
           VerifyOffset(verifier, VT_CG) &&
           verifier.VerifyTable(cg()) &&
           VerifyOffset(verifier, VT_MOMENT_ARMS) &&
           verifier.VerifyVector(moment_arms()) &&
           VerifyOffset(verifier, VT_MOI_3X1) &&
           verifier.VerifyTable(moi_3x1()) &&
           VerifyOffset(verifier, VT_MOI_3X3) &&
           verifier.VerifyVector(moi_3x3()) &&
           VerifyOffset(verifier, VT_EXTRA_PROPS) &&
           verifier.VerifyVector(extra_props()) &&
           VerifyOffset(verifier, VT_COLLISIONS) &&
           verifier.VerifyVector(collisions()) &&
           verifier.VerifyVectorOfTables(collisions()) &&
           VerifyOffset(verifier, VT_IMAGE_DATA_0) &&
           verifier.VerifyVector(image_data_0()) &&
           VerifyOffset(verifier, VT_IMAGE_DATA_1) &&
           verifier.VerifyVector(image_data_1()) &&
           verifier.EndTable();
  }
  StatesMsgT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatesMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StatesMsg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StatesMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatesMsgBuilder {
  typedef StatesMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(StatesMsg::VT_NAME, name);
  }
  void add_sys_id(uint32_t sys_id) {
    fbb_.AddElement<uint32_t>(StatesMsg::VT_SYS_ID, sys_id, 0);
  }
  void add_timestamp(double timestamp) {
    fbb_.AddElement<double>(StatesMsg::VT_TIMESTAMP, timestamp, 0.0);
  }
  void add_lin_acc(::flatbuffers::Offset<Vec3Msg> lin_acc) {
    fbb_.AddOffset(StatesMsg::VT_LIN_ACC, lin_acc);
  }
  void add_lin_vel(::flatbuffers::Offset<Vec3Msg> lin_vel) {
    fbb_.AddOffset(StatesMsg::VT_LIN_VEL, lin_vel);
  }
  void add_lin_pos(::flatbuffers::Offset<Vec3Msg> lin_pos) {
    fbb_.AddOffset(StatesMsg::VT_LIN_POS, lin_pos);
  }
  void add_altitude(float altitude) {
    fbb_.AddElement<float>(StatesMsg::VT_ALTITUDE, altitude, 0.0f);
  }
  void add_ang_acc(::flatbuffers::Offset<Vec3Msg> ang_acc) {
    fbb_.AddOffset(StatesMsg::VT_ANG_ACC, ang_acc);
  }
  void add_ang_vel(::flatbuffers::Offset<Vec3Msg> ang_vel) {
    fbb_.AddOffset(StatesMsg::VT_ANG_VEL, ang_vel);
  }
  void add_euler(::flatbuffers::Offset<Vec3Msg> euler) {
    fbb_.AddOffset(StatesMsg::VT_EULER, euler);
  }
  void add_euler_dot(::flatbuffers::Offset<Vec3Msg> euler_dot) {
    fbb_.AddOffset(StatesMsg::VT_EULER_DOT, euler_dot);
  }
  void add_quaternion(::flatbuffers::Offset<Vec4Msg> quaternion) {
    fbb_.AddOffset(StatesMsg::VT_QUATERNION, quaternion);
  }
  void add_pwm(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> pwm) {
    fbb_.AddOffset(StatesMsg::VT_PWM, pwm);
  }
  void add_actuators(::flatbuffers::Offset<::flatbuffers::Vector<float>> actuators) {
    fbb_.AddOffset(StatesMsg::VT_ACTUATORS, actuators);
  }
  void add_force(::flatbuffers::Offset<Vec3Msg> force) {
    fbb_.AddOffset(StatesMsg::VT_FORCE, force);
  }
  void add_torque(::flatbuffers::Offset<Vec3Msg> torque) {
    fbb_.AddOffset(StatesMsg::VT_TORQUE, torque);
  }
  void add_accelerometer(::flatbuffers::Offset<Vec3Msg> accelerometer) {
    fbb_.AddOffset(StatesMsg::VT_ACCELEROMETER, accelerometer);
  }
  void add_gyroscope(::flatbuffers::Offset<Vec3Msg> gyroscope) {
    fbb_.AddOffset(StatesMsg::VT_GYROSCOPE, gyroscope);
  }
  void add_magnetometer(::flatbuffers::Offset<Vec3Msg> magnetometer) {
    fbb_.AddOffset(StatesMsg::VT_MAGNETOMETER, magnetometer);
  }
  void add_barometer(float barometer) {
    fbb_.AddElement<float>(StatesMsg::VT_BAROMETER, barometer, 0.0f);
  }
  void add_temperature(float temperature) {
    fbb_.AddElement<float>(StatesMsg::VT_TEMPERATURE, temperature, 0.0f);
  }
  void add_gps_pos(::flatbuffers::Offset<Vec3Msg> gps_pos) {
    fbb_.AddOffset(StatesMsg::VT_GPS_POS, gps_pos);
  }
  void add_gps_vel(::flatbuffers::Offset<Vec3Msg> gps_vel) {
    fbb_.AddOffset(StatesMsg::VT_GPS_VEL, gps_vel);
  }
  void add_mass(float mass) {
    fbb_.AddElement<float>(StatesMsg::VT_MASS, mass, 0.0f);
  }
  void add_cg(::flatbuffers::Offset<Vec3Msg> cg) {
    fbb_.AddOffset(StatesMsg::VT_CG, cg);
  }
  void add_moment_arms(::flatbuffers::Offset<::flatbuffers::Vector<float>> moment_arms) {
    fbb_.AddOffset(StatesMsg::VT_MOMENT_ARMS, moment_arms);
  }
  void add_moi_3x1(::flatbuffers::Offset<Vec3Msg> moi_3x1) {
    fbb_.AddOffset(StatesMsg::VT_MOI_3X1, moi_3x1);
  }
  void add_moi_3x3(::flatbuffers::Offset<::flatbuffers::Vector<float>> moi_3x3) {
    fbb_.AddOffset(StatesMsg::VT_MOI_3X3, moi_3x3);
  }
  void add_extra_props(::flatbuffers::Offset<::flatbuffers::Vector<float>> extra_props) {
    fbb_.AddOffset(StatesMsg::VT_EXTRA_PROPS, extra_props);
  }
  void add_collisions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Collision>>> collisions) {
    fbb_.AddOffset(StatesMsg::VT_COLLISIONS, collisions);
  }
  void add_image_data_0(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> image_data_0) {
    fbb_.AddOffset(StatesMsg::VT_IMAGE_DATA_0, image_data_0);
  }
  void add_image_data_1(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> image_data_1) {
    fbb_.AddOffset(StatesMsg::VT_IMAGE_DATA_1, image_data_1);
  }
  explicit StatesMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatesMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatesMsg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatesMsg> CreateStatesMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t sys_id = 0,
    double timestamp = 0.0,
    ::flatbuffers::Offset<Vec3Msg> lin_acc = 0,
    ::flatbuffers::Offset<Vec3Msg> lin_vel = 0,
    ::flatbuffers::Offset<Vec3Msg> lin_pos = 0,
    float altitude = 0.0f,
    ::flatbuffers::Offset<Vec3Msg> ang_acc = 0,
    ::flatbuffers::Offset<Vec3Msg> ang_vel = 0,
    ::flatbuffers::Offset<Vec3Msg> euler = 0,
    ::flatbuffers::Offset<Vec3Msg> euler_dot = 0,
    ::flatbuffers::Offset<Vec4Msg> quaternion = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> pwm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> actuators = 0,
    ::flatbuffers::Offset<Vec3Msg> force = 0,
    ::flatbuffers::Offset<Vec3Msg> torque = 0,
    ::flatbuffers::Offset<Vec3Msg> accelerometer = 0,
    ::flatbuffers::Offset<Vec3Msg> gyroscope = 0,
    ::flatbuffers::Offset<Vec3Msg> magnetometer = 0,
    float barometer = 0.0f,
    float temperature = 0.0f,
    ::flatbuffers::Offset<Vec3Msg> gps_pos = 0,
    ::flatbuffers::Offset<Vec3Msg> gps_vel = 0,
    float mass = 0.0f,
    ::flatbuffers::Offset<Vec3Msg> cg = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> moment_arms = 0,
    ::flatbuffers::Offset<Vec3Msg> moi_3x1 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> moi_3x3 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> extra_props = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Collision>>> collisions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> image_data_0 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> image_data_1 = 0) {
  StatesMsgBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_image_data_1(image_data_1);
  builder_.add_image_data_0(image_data_0);
  builder_.add_collisions(collisions);
  builder_.add_extra_props(extra_props);
  builder_.add_moi_3x3(moi_3x3);
  builder_.add_moi_3x1(moi_3x1);
  builder_.add_moment_arms(moment_arms);
  builder_.add_cg(cg);
  builder_.add_mass(mass);
  builder_.add_gps_vel(gps_vel);
  builder_.add_gps_pos(gps_pos);
  builder_.add_temperature(temperature);
  builder_.add_barometer(barometer);
  builder_.add_magnetometer(magnetometer);
  builder_.add_gyroscope(gyroscope);
  builder_.add_accelerometer(accelerometer);
  builder_.add_torque(torque);
  builder_.add_force(force);
  builder_.add_actuators(actuators);
  builder_.add_pwm(pwm);
  builder_.add_quaternion(quaternion);
  builder_.add_euler_dot(euler_dot);
  builder_.add_euler(euler);
  builder_.add_ang_vel(ang_vel);
  builder_.add_ang_acc(ang_acc);
  builder_.add_altitude(altitude);
  builder_.add_lin_pos(lin_pos);
  builder_.add_lin_vel(lin_vel);
  builder_.add_lin_acc(lin_acc);
  builder_.add_sys_id(sys_id);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatesMsg> CreateStatesMsgDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t sys_id = 0,
    double timestamp = 0.0,
    ::flatbuffers::Offset<Vec3Msg> lin_acc = 0,
    ::flatbuffers::Offset<Vec3Msg> lin_vel = 0,
    ::flatbuffers::Offset<Vec3Msg> lin_pos = 0,
    float altitude = 0.0f,
    ::flatbuffers::Offset<Vec3Msg> ang_acc = 0,
    ::flatbuffers::Offset<Vec3Msg> ang_vel = 0,
    ::flatbuffers::Offset<Vec3Msg> euler = 0,
    ::flatbuffers::Offset<Vec3Msg> euler_dot = 0,
    ::flatbuffers::Offset<Vec4Msg> quaternion = 0,
    const std::vector<uint32_t> *pwm = nullptr,
    const std::vector<float> *actuators = nullptr,
    ::flatbuffers::Offset<Vec3Msg> force = 0,
    ::flatbuffers::Offset<Vec3Msg> torque = 0,
    ::flatbuffers::Offset<Vec3Msg> accelerometer = 0,
    ::flatbuffers::Offset<Vec3Msg> gyroscope = 0,
    ::flatbuffers::Offset<Vec3Msg> magnetometer = 0,
    float barometer = 0.0f,
    float temperature = 0.0f,
    ::flatbuffers::Offset<Vec3Msg> gps_pos = 0,
    ::flatbuffers::Offset<Vec3Msg> gps_vel = 0,
    float mass = 0.0f,
    ::flatbuffers::Offset<Vec3Msg> cg = 0,
    const std::vector<float> *moment_arms = nullptr,
    ::flatbuffers::Offset<Vec3Msg> moi_3x1 = 0,
    const std::vector<float> *moi_3x3 = nullptr,
    const std::vector<float> *extra_props = nullptr,
    const std::vector<::flatbuffers::Offset<Collision>> *collisions = nullptr,
    const std::vector<uint8_t> *image_data_0 = nullptr,
    const std::vector<uint8_t> *image_data_1 = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto pwm__ = pwm ? _fbb.CreateVector<uint32_t>(*pwm) : 0;
  auto actuators__ = actuators ? _fbb.CreateVector<float>(*actuators) : 0;
  auto moment_arms__ = moment_arms ? _fbb.CreateVector<float>(*moment_arms) : 0;
  auto moi_3x3__ = moi_3x3 ? _fbb.CreateVector<float>(*moi_3x3) : 0;
  auto extra_props__ = extra_props ? _fbb.CreateVector<float>(*extra_props) : 0;
  auto collisions__ = collisions ? _fbb.CreateVector<::flatbuffers::Offset<Collision>>(*collisions) : 0;
  auto image_data_0__ = image_data_0 ? _fbb.CreateVector<uint8_t>(*image_data_0) : 0;
  auto image_data_1__ = image_data_1 ? _fbb.CreateVector<uint8_t>(*image_data_1) : 0;
  return CreateStatesMsg(
      _fbb,
      name__,
      sys_id,
      timestamp,
      lin_acc,
      lin_vel,
      lin_pos,
      altitude,
      ang_acc,
      ang_vel,
      euler,
      euler_dot,
      quaternion,
      pwm__,
      actuators__,
      force,
      torque,
      accelerometer,
      gyroscope,
      magnetometer,
      barometer,
      temperature,
      gps_pos,
      gps_vel,
      mass,
      cg,
      moment_arms__,
      moi_3x1,
      moi_3x3__,
      extra_props__,
      collisions__,
      image_data_0__,
      image_data_1__);
}

::flatbuffers::Offset<StatesMsg> CreateStatesMsg(::flatbuffers::FlatBufferBuilder &_fbb, const StatesMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Vec3MsgT *Vec3Msg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Vec3MsgT>(new Vec3MsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Vec3Msg::UnPackTo(Vec3MsgT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline ::flatbuffers::Offset<Vec3Msg> Vec3Msg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Vec3MsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVec3Msg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Vec3Msg> CreateVec3Msg(::flatbuffers::FlatBufferBuilder &_fbb, const Vec3MsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Vec3MsgT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return CreateVec3Msg(
      _fbb,
      _x,
      _y,
      _z);
}

inline Vec4MsgT *Vec4Msg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Vec4MsgT>(new Vec4MsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Vec4Msg::UnPackTo(Vec4MsgT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = w(); _o->w = _e; }
}

inline ::flatbuffers::Offset<Vec4Msg> Vec4Msg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Vec4MsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVec4Msg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Vec4Msg> CreateVec4Msg(::flatbuffers::FlatBufferBuilder &_fbb, const Vec4MsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Vec4MsgT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _w = _o->w;
  return CreateVec4Msg(
      _fbb,
      _x,
      _y,
      _z,
      _w);
}

inline CollisionT::CollisionT(const CollisionT &o)
      : timestamp(o.timestamp),
        collision_type(o.collision_type),
        object_name(o.object_name),
        pos((o.pos) ? new Vec3MsgT(*o.pos) : nullptr),
        vel((o.vel) ? new Vec3MsgT(*o.vel) : nullptr),
        eul((o.eul) ? new Vec3MsgT(*o.eul) : nullptr),
        angvel((o.angvel) ? new Vec3MsgT(*o.angvel) : nullptr) {
}

inline CollisionT &CollisionT::operator=(CollisionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(timestamp, o.timestamp);
  std::swap(collision_type, o.collision_type);
  std::swap(object_name, o.object_name);
  std::swap(pos, o.pos);
  std::swap(vel, o.vel);
  std::swap(eul, o.eul);
  std::swap(angvel, o.angvel);
  return *this;
}

inline CollisionT *Collision::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CollisionT>(new CollisionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Collision::UnPackTo(CollisionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = timestamp(); _o->timestamp = _e; }
  { auto _e = collision_type(); _o->collision_type = _e; }
  { auto _e = object_name(); if (_e) _o->object_name = _e->str(); }
  { auto _e = pos(); if (_e) { if(_o->pos) { _e->UnPackTo(_o->pos.get(), _resolver); } else { _o->pos = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->pos) { _o->pos.reset(); } }
  { auto _e = vel(); if (_e) { if(_o->vel) { _e->UnPackTo(_o->vel.get(), _resolver); } else { _o->vel = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->vel) { _o->vel.reset(); } }
  { auto _e = eul(); if (_e) { if(_o->eul) { _e->UnPackTo(_o->eul.get(), _resolver); } else { _o->eul = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->eul) { _o->eul.reset(); } }
  { auto _e = angvel(); if (_e) { if(_o->angvel) { _e->UnPackTo(_o->angvel.get(), _resolver); } else { _o->angvel = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->angvel) { _o->angvel.reset(); } }
}

inline ::flatbuffers::Offset<Collision> Collision::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CollisionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCollision(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Collision> CreateCollision(::flatbuffers::FlatBufferBuilder &_fbb, const CollisionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CollisionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _timestamp = _o->timestamp;
  auto _collision_type = _o->collision_type;
  auto _object_name = _o->object_name.empty() ? 0 : _fbb.CreateString(_o->object_name);
  auto _pos = _o->pos ? CreateVec3Msg(_fbb, _o->pos.get(), _rehasher) : 0;
  auto _vel = _o->vel ? CreateVec3Msg(_fbb, _o->vel.get(), _rehasher) : 0;
  auto _eul = _o->eul ? CreateVec3Msg(_fbb, _o->eul.get(), _rehasher) : 0;
  auto _angvel = _o->angvel ? CreateVec3Msg(_fbb, _o->angvel.get(), _rehasher) : 0;
  return CreateCollision(
      _fbb,
      _timestamp,
      _collision_type,
      _object_name,
      _pos,
      _vel,
      _eul,
      _angvel);
}

inline StatesMsgT::StatesMsgT(const StatesMsgT &o)
      : name(o.name),
        sys_id(o.sys_id),
        timestamp(o.timestamp),
        lin_acc((o.lin_acc) ? new Vec3MsgT(*o.lin_acc) : nullptr),
        lin_vel((o.lin_vel) ? new Vec3MsgT(*o.lin_vel) : nullptr),
        lin_pos((o.lin_pos) ? new Vec3MsgT(*o.lin_pos) : nullptr),
        altitude(o.altitude),
        ang_acc((o.ang_acc) ? new Vec3MsgT(*o.ang_acc) : nullptr),
        ang_vel((o.ang_vel) ? new Vec3MsgT(*o.ang_vel) : nullptr),
        euler((o.euler) ? new Vec3MsgT(*o.euler) : nullptr),
        euler_dot((o.euler_dot) ? new Vec3MsgT(*o.euler_dot) : nullptr),
        quaternion((o.quaternion) ? new Vec4MsgT(*o.quaternion) : nullptr),
        pwm(o.pwm),
        actuators(o.actuators),
        force((o.force) ? new Vec3MsgT(*o.force) : nullptr),
        torque((o.torque) ? new Vec3MsgT(*o.torque) : nullptr),
        accelerometer((o.accelerometer) ? new Vec3MsgT(*o.accelerometer) : nullptr),
        gyroscope((o.gyroscope) ? new Vec3MsgT(*o.gyroscope) : nullptr),
        magnetometer((o.magnetometer) ? new Vec3MsgT(*o.magnetometer) : nullptr),
        barometer(o.barometer),
        temperature(o.temperature),
        gps_pos((o.gps_pos) ? new Vec3MsgT(*o.gps_pos) : nullptr),
        gps_vel((o.gps_vel) ? new Vec3MsgT(*o.gps_vel) : nullptr),
        mass(o.mass),
        cg((o.cg) ? new Vec3MsgT(*o.cg) : nullptr),
        moment_arms(o.moment_arms),
        moi_3x1((o.moi_3x1) ? new Vec3MsgT(*o.moi_3x1) : nullptr),
        moi_3x3(o.moi_3x3),
        extra_props(o.extra_props),
        image_data_0(o.image_data_0),
        image_data_1(o.image_data_1) {
  collisions.reserve(o.collisions.size());
  for (const auto &collisions_ : o.collisions) { collisions.emplace_back((collisions_) ? new CollisionT(*collisions_) : nullptr); }
}

inline StatesMsgT &StatesMsgT::operator=(StatesMsgT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(sys_id, o.sys_id);
  std::swap(timestamp, o.timestamp);
  std::swap(lin_acc, o.lin_acc);
  std::swap(lin_vel, o.lin_vel);
  std::swap(lin_pos, o.lin_pos);
  std::swap(altitude, o.altitude);
  std::swap(ang_acc, o.ang_acc);
  std::swap(ang_vel, o.ang_vel);
  std::swap(euler, o.euler);
  std::swap(euler_dot, o.euler_dot);
  std::swap(quaternion, o.quaternion);
  std::swap(pwm, o.pwm);
  std::swap(actuators, o.actuators);
  std::swap(force, o.force);
  std::swap(torque, o.torque);
  std::swap(accelerometer, o.accelerometer);
  std::swap(gyroscope, o.gyroscope);
  std::swap(magnetometer, o.magnetometer);
  std::swap(barometer, o.barometer);
  std::swap(temperature, o.temperature);
  std::swap(gps_pos, o.gps_pos);
  std::swap(gps_vel, o.gps_vel);
  std::swap(mass, o.mass);
  std::swap(cg, o.cg);
  std::swap(moment_arms, o.moment_arms);
  std::swap(moi_3x1, o.moi_3x1);
  std::swap(moi_3x3, o.moi_3x3);
  std::swap(extra_props, o.extra_props);
  std::swap(collisions, o.collisions);
  std::swap(image_data_0, o.image_data_0);
  std::swap(image_data_1, o.image_data_1);
  return *this;
}

inline StatesMsgT *StatesMsg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StatesMsgT>(new StatesMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StatesMsg::UnPackTo(StatesMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = sys_id(); _o->sys_id = _e; }
  { auto _e = timestamp(); _o->timestamp = _e; }
  { auto _e = lin_acc(); if (_e) { if(_o->lin_acc) { _e->UnPackTo(_o->lin_acc.get(), _resolver); } else { _o->lin_acc = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->lin_acc) { _o->lin_acc.reset(); } }
  { auto _e = lin_vel(); if (_e) { if(_o->lin_vel) { _e->UnPackTo(_o->lin_vel.get(), _resolver); } else { _o->lin_vel = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->lin_vel) { _o->lin_vel.reset(); } }
  { auto _e = lin_pos(); if (_e) { if(_o->lin_pos) { _e->UnPackTo(_o->lin_pos.get(), _resolver); } else { _o->lin_pos = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->lin_pos) { _o->lin_pos.reset(); } }
  { auto _e = altitude(); _o->altitude = _e; }
  { auto _e = ang_acc(); if (_e) { if(_o->ang_acc) { _e->UnPackTo(_o->ang_acc.get(), _resolver); } else { _o->ang_acc = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->ang_acc) { _o->ang_acc.reset(); } }
  { auto _e = ang_vel(); if (_e) { if(_o->ang_vel) { _e->UnPackTo(_o->ang_vel.get(), _resolver); } else { _o->ang_vel = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->ang_vel) { _o->ang_vel.reset(); } }
  { auto _e = euler(); if (_e) { if(_o->euler) { _e->UnPackTo(_o->euler.get(), _resolver); } else { _o->euler = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->euler) { _o->euler.reset(); } }
  { auto _e = euler_dot(); if (_e) { if(_o->euler_dot) { _e->UnPackTo(_o->euler_dot.get(), _resolver); } else { _o->euler_dot = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->euler_dot) { _o->euler_dot.reset(); } }
  { auto _e = quaternion(); if (_e) { if(_o->quaternion) { _e->UnPackTo(_o->quaternion.get(), _resolver); } else { _o->quaternion = std::unique_ptr<Vec4MsgT>(_e->UnPack(_resolver)); } } else if (_o->quaternion) { _o->quaternion.reset(); } }
  { auto _e = pwm(); if (_e) { _o->pwm.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pwm[_i] = _e->Get(_i); } } else { _o->pwm.resize(0); } }
  { auto _e = actuators(); if (_e) { _o->actuators.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->actuators[_i] = _e->Get(_i); } } else { _o->actuators.resize(0); } }
  { auto _e = force(); if (_e) { if(_o->force) { _e->UnPackTo(_o->force.get(), _resolver); } else { _o->force = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->force) { _o->force.reset(); } }
  { auto _e = torque(); if (_e) { if(_o->torque) { _e->UnPackTo(_o->torque.get(), _resolver); } else { _o->torque = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->torque) { _o->torque.reset(); } }
  { auto _e = accelerometer(); if (_e) { if(_o->accelerometer) { _e->UnPackTo(_o->accelerometer.get(), _resolver); } else { _o->accelerometer = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->accelerometer) { _o->accelerometer.reset(); } }
  { auto _e = gyroscope(); if (_e) { if(_o->gyroscope) { _e->UnPackTo(_o->gyroscope.get(), _resolver); } else { _o->gyroscope = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->gyroscope) { _o->gyroscope.reset(); } }
  { auto _e = magnetometer(); if (_e) { if(_o->magnetometer) { _e->UnPackTo(_o->magnetometer.get(), _resolver); } else { _o->magnetometer = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->magnetometer) { _o->magnetometer.reset(); } }
  { auto _e = barometer(); _o->barometer = _e; }
  { auto _e = temperature(); _o->temperature = _e; }
  { auto _e = gps_pos(); if (_e) { if(_o->gps_pos) { _e->UnPackTo(_o->gps_pos.get(), _resolver); } else { _o->gps_pos = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->gps_pos) { _o->gps_pos.reset(); } }
  { auto _e = gps_vel(); if (_e) { if(_o->gps_vel) { _e->UnPackTo(_o->gps_vel.get(), _resolver); } else { _o->gps_vel = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->gps_vel) { _o->gps_vel.reset(); } }
  { auto _e = mass(); _o->mass = _e; }
  { auto _e = cg(); if (_e) { if(_o->cg) { _e->UnPackTo(_o->cg.get(), _resolver); } else { _o->cg = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->cg) { _o->cg.reset(); } }
  { auto _e = moment_arms(); if (_e) { _o->moment_arms.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->moment_arms[_i] = _e->Get(_i); } } else { _o->moment_arms.resize(0); } }
  { auto _e = moi_3x1(); if (_e) { if(_o->moi_3x1) { _e->UnPackTo(_o->moi_3x1.get(), _resolver); } else { _o->moi_3x1 = std::unique_ptr<Vec3MsgT>(_e->UnPack(_resolver)); } } else if (_o->moi_3x1) { _o->moi_3x1.reset(); } }
  { auto _e = moi_3x3(); if (_e) { _o->moi_3x3.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->moi_3x3[_i] = _e->Get(_i); } } else { _o->moi_3x3.resize(0); } }
  { auto _e = extra_props(); if (_e) { _o->extra_props.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extra_props[_i] = _e->Get(_i); } } else { _o->extra_props.resize(0); } }
  { auto _e = collisions(); if (_e) { _o->collisions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->collisions[_i]) { _e->Get(_i)->UnPackTo(_o->collisions[_i].get(), _resolver); } else { _o->collisions[_i] = std::unique_ptr<CollisionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->collisions.resize(0); } }
  { auto _e = image_data_0(); if (_e) { _o->image_data_0.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->image_data_0.begin()); } }
  { auto _e = image_data_1(); if (_e) { _o->image_data_1.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->image_data_1.begin()); } }
}

inline ::flatbuffers::Offset<StatesMsg> StatesMsg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StatesMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatesMsg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StatesMsg> CreateStatesMsg(::flatbuffers::FlatBufferBuilder &_fbb, const StatesMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StatesMsgT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _sys_id = _o->sys_id;
  auto _timestamp = _o->timestamp;
  auto _lin_acc = _o->lin_acc ? CreateVec3Msg(_fbb, _o->lin_acc.get(), _rehasher) : 0;
  auto _lin_vel = _o->lin_vel ? CreateVec3Msg(_fbb, _o->lin_vel.get(), _rehasher) : 0;
  auto _lin_pos = _o->lin_pos ? CreateVec3Msg(_fbb, _o->lin_pos.get(), _rehasher) : 0;
  auto _altitude = _o->altitude;
  auto _ang_acc = _o->ang_acc ? CreateVec3Msg(_fbb, _o->ang_acc.get(), _rehasher) : 0;
  auto _ang_vel = _o->ang_vel ? CreateVec3Msg(_fbb, _o->ang_vel.get(), _rehasher) : 0;
  auto _euler = _o->euler ? CreateVec3Msg(_fbb, _o->euler.get(), _rehasher) : 0;
  auto _euler_dot = _o->euler_dot ? CreateVec3Msg(_fbb, _o->euler_dot.get(), _rehasher) : 0;
  auto _quaternion = _o->quaternion ? CreateVec4Msg(_fbb, _o->quaternion.get(), _rehasher) : 0;
  auto _pwm = _o->pwm.size() ? _fbb.CreateVector(_o->pwm) : 0;
  auto _actuators = _o->actuators.size() ? _fbb.CreateVector(_o->actuators) : 0;
  auto _force = _o->force ? CreateVec3Msg(_fbb, _o->force.get(), _rehasher) : 0;
  auto _torque = _o->torque ? CreateVec3Msg(_fbb, _o->torque.get(), _rehasher) : 0;
  auto _accelerometer = _o->accelerometer ? CreateVec3Msg(_fbb, _o->accelerometer.get(), _rehasher) : 0;
  auto _gyroscope = _o->gyroscope ? CreateVec3Msg(_fbb, _o->gyroscope.get(), _rehasher) : 0;
  auto _magnetometer = _o->magnetometer ? CreateVec3Msg(_fbb, _o->magnetometer.get(), _rehasher) : 0;
  auto _barometer = _o->barometer;
  auto _temperature = _o->temperature;
  auto _gps_pos = _o->gps_pos ? CreateVec3Msg(_fbb, _o->gps_pos.get(), _rehasher) : 0;
  auto _gps_vel = _o->gps_vel ? CreateVec3Msg(_fbb, _o->gps_vel.get(), _rehasher) : 0;
  auto _mass = _o->mass;
  auto _cg = _o->cg ? CreateVec3Msg(_fbb, _o->cg.get(), _rehasher) : 0;
  auto _moment_arms = _o->moment_arms.size() ? _fbb.CreateVector(_o->moment_arms) : 0;
  auto _moi_3x1 = _o->moi_3x1 ? CreateVec3Msg(_fbb, _o->moi_3x1.get(), _rehasher) : 0;
  auto _moi_3x3 = _o->moi_3x3.size() ? _fbb.CreateVector(_o->moi_3x3) : 0;
  auto _extra_props = _o->extra_props.size() ? _fbb.CreateVector(_o->extra_props) : 0;
  auto _collisions = _o->collisions.size() ? _fbb.CreateVector<::flatbuffers::Offset<Collision>> (_o->collisions.size(), [](size_t i, _VectorArgs *__va) { return CreateCollision(*__va->__fbb, __va->__o->collisions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _image_data_0 = _o->image_data_0.size() ? _fbb.CreateVector(_o->image_data_0) : 0;
  auto _image_data_1 = _o->image_data_1.size() ? _fbb.CreateVector(_o->image_data_1) : 0;
  return CreateStatesMsg(
      _fbb,
      _name,
      _sys_id,
      _timestamp,
      _lin_acc,
      _lin_vel,
      _lin_pos,
      _altitude,
      _ang_acc,
      _ang_vel,
      _euler,
      _euler_dot,
      _quaternion,
      _pwm,
      _actuators,
      _force,
      _torque,
      _accelerometer,
      _gyroscope,
      _magnetometer,
      _barometer,
      _temperature,
      _gps_pos,
      _gps_vel,
      _mass,
      _cg,
      _moment_arms,
      _moi_3x1,
      _moi_3x3,
      _extra_props,
      _collisions,
      _image_data_0,
      _image_data_1);
}

inline const StatesMsg *GetStatesMsg(const void *buf) {
  return ::flatbuffers::GetRoot<StatesMsg>(buf);
}

inline const StatesMsg *GetSizePrefixedStatesMsg(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<StatesMsg>(buf);
}

inline const char *StatesMsgIdentifier() {
  return "R000";
}

inline bool StatesMsgBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, StatesMsgIdentifier());
}

inline bool SizePrefixedStatesMsgBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, StatesMsgIdentifier(), true);
}

inline bool VerifyStatesMsgBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<StatesMsg>(StatesMsgIdentifier());
}

inline bool VerifySizePrefixedStatesMsgBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<StatesMsg>(StatesMsgIdentifier());
}

inline void FinishStatesMsgBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<StatesMsg> root) {
  fbb.Finish(root, StatesMsgIdentifier());
}

inline void FinishSizePrefixedStatesMsgBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<StatesMsg> root) {
  fbb.FinishSizePrefixed(root, StatesMsgIdentifier());
}

inline std::unique_ptr<StatesMsgT> UnPackStatesMsg(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<StatesMsgT>(GetStatesMsg(buf)->UnPack(res));
}

inline std::unique_ptr<StatesMsgT> UnPackSizePrefixedStatesMsg(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<StatesMsgT>(GetSizePrefixedStatesMsg(buf)->UnPack(res));
}

#endif  // FLATBUFFERS_GENERATED_R000STATES_H_
